"use strict";
const fs = require('fs-extra-promise');
const node_path = require('path');
function walk(path, filter, options) {
    if (!options) {
        options = { ignoreHiddenFile: true, relative: false };
    }
    if (typeof path === 'string') {
        return _walk(path, filter, options);
    }
    else {
        return new Promise((reslove, reject) => {
            var index = -1;
            function execute(result) {
                index++;
                if (!path[index]) {
                    reslove(result);
                }
                else {
                    walk(path[index], filter, options).then((v) => execute(v.concat(result)));
                }
            }
            execute([]);
        });
    }
}
exports.walk = walk;
function _walk(path, filter, options) {
    let isFinished = false;
    let result = [];
    fs.walk(path)
        .on("data", (obj) => {
        let p = obj.path;
        if (obj.stats.isFile() && filter(p, obj.stats)) {
            if (options.ignoreHiddenFile && node_path.basename(p).indexOf(".") == 0) {
            }
            if (options.relative) {
                p = node_path.relative(path, p);
            }
            p = p.replace(/\\/g, "/");
            result.push(p);
        }
    })
        .on("end", () => { isFinished = true; });
    return new Promise((reslove, reject) => {
        function ticker() {
            if (isFinished) {
                reslove(result);
            }
            else {
                setTimeout(ticker, 100);
            }
        }
        setTimeout(ticker, 100);
    });
}
const cp = require('child_process');
exports.shell = (path, args, opt, verbase) => {
    let stdout = "";
    let stderr = "";
    var cmd = `${path} ${args.join(" ")}`;
    if (verbase) {
        console.log(cmd);
    }
    let printStdoutBufferMessage = (message) => {
        var str = message.toString();
        stdout += str;
        if (verbase) {
            console.log(str);
        }
    };
    let printStderrBufferMessage = (message) => {
        var str = message.toString();
        stderr += str;
        if (verbase) {
            console.log(str);
        }
    };
    let callback = (reslove, reject) => {
        var shell = cp.spawn(path, args, opt);
        shell.on("error", (message) => { console.log(message); });
        shell.stderr.on("data", printStderrBufferMessage);
        shell.stderr.on("error", printStderrBufferMessage);
        shell.stdout.on("data", printStdoutBufferMessage);
        shell.stdout.on("error", printStdoutBufferMessage);
        shell.on('exit', function (code) {
            if (code != 0) {
                if (verbase) {
                    console.log('Failed: ' + code);
                }
                reject({ code: code, stdout: stdout, stderr: stderr });
            }
            else {
                reslove({ code: code, stdout: stdout, stderr: stderr });
            }
        });
    };
    return new Promise(callback);
};
exports.sleep = time => {
    return new Promise((reslove) => setTimeout(reslove, time));
};
